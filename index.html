<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cu·ªôc Chi·∫øn Con Tr·ªè | Cursor Clash</title>
    <!-- T·∫£i Tailwind CSS cho styling hi·ªán ƒë·∫°i v√† responsive -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* 1. ·∫®n/Hi·ªán con tr·ªè chu·ªôt h·ªá th·ªëng d·ª±a tr√™n class */
        body, #game-container, button, #boss, .projectile, #start-screen {
            font-family: 'Inter', sans-serif;
            user-select: none; /* R·∫•t quan tr·ªçng: Ch·∫∑n b√¥i ƒëen/ch·ªçn ch·ªØ */
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
        
        /* CLASS D√ôNG ƒê·ªÇ ·∫®N con tr·ªè h·ªá th·ªëng (CH·ªà D√ôNG KHI CH∆†I GAME) */
        .hide-cursor {
            cursor: none !important;
        }
        /* CLASS D√ôNG ƒê·ªÇ HI·ªÜN con tr·ªè h·ªá th·ªëng (M·∫∑c ƒë·ªãnh ho·∫∑c GAME OVER) */
        .show-cursor {
            cursor: default !important;
        }

        /* 2. Style cho con tr·ªè chu·ªôt custom (Chu·ªôt ch√≠nh c·ªßa ng∆∞·ªùi ch∆°i) */
        #custom-cursor {
            position: fixed;
            pointer-events: none; 
            width: 40px; 
            height: 40px;
            transform: translate(-50%, -50%);
            /* Th√™m transition cho hi·ªáu ·ª©ng l·∫•p l√°nh (hit) */
            filter: drop-shadow(0 0 5px rgba(252, 165, 165, 0.7)); 
            transition: transform 0.05s ease-out, opacity 0.1s, filter 0.1s; 
            z-index: 10000;
        }
        
        /* Hi·ªáu ·ª©ng khi con tr·ªè b·ªã tr√∫ng ƒë·∫°n */
        .cursor-hit {
            filter: brightness(200%) drop-shadow(0 0 10px red); 
            opacity: 0.5; /* L·∫•p l√°nh */
            animation: hit-flash 0.1s;
        }

        @keyframes hit-flash {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.1); }
        }

        /* 3. Style cho con tr·ªè "FAKE" v√† M·∫¢NH V·ª† khi thua */
        #fake-cursor-shatter {
            position: absolute;
            width: 40px;
            height: 40px;
            z-index: 10001;
            display: none; 
            animation: shatter-effect 0.8s forwards;
        }

        .fragment {
            position: absolute;
            width: 8px;
            height: 8px;
            background-color: #fca5a5; /* M√†u ƒë·ªè nh·∫°t c·ªßa con tr·ªè */
            border-radius: 50%;
            pointer-events: none;
            z-index: 9999;
            transition: opacity 0.5s;
        }

        /* Keyframes cho hi·ªáu ·ª©ng V·ª† TAN T√ÄNH (cho chu·ªôt fake) */
        @keyframes shatter-effect {
            0% { opacity: 1; transform: translate(-50%, -50%) scale(1) rotate(0deg); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(0) rotate(90deg); }
        }
        
        /* Hi·ªáu ·ª©ng rung l·∫Øc khi Boss t·∫•n c√¥ng */
        @keyframes screen-shake {
            0% { transform: translate(1px, 1px) rotate(0deg); }
            20% { transform: translate(-1px, -2px) rotate(-1deg); }
            40% { transform: translate(-3px, 0px) rotate(1deg); }
            60% { transform: translate(3px, 2px) rotate(0deg); }
            80% { transform: translate(-1px, -1px) rotate(-1deg); }
            100% { transform: translate(1px, 1px) rotate(0deg); }
        }
        .shake-screen {
            animation: screen-shake 0.3s cubic-bezier(.36,.07,.19,.97) both;
            transform: translate3d(0, 0, 0);
            backface-visibility: hidden;
            perspective: 1000px;
        }

        /* 4. Style cho Boss v√† ƒë·∫°n */
        #boss {
            position: absolute;
            width: 80px;
            height: 80px;
            transition: left 2s ease-in-out, top 2s ease-in-out; 
            line-height: 80px;
            text-align: center;
            font-size: 60px;
            border-radius: 50%;
            /* M√†u m·∫∑c ƒë·ªãnh khi s·∫µn s√†ng n√©m (throwable) */
            box-shadow: 0 0 15px rgba(239, 68, 68, 0.8);
            background-color: rgba(239, 68, 68, 0.5); 
            /* Transition cho m√†u s·∫Øc box-shadow */
            transition: all 0.2s ease-in-out, left 2s ease-in-out, top 2s ease-in-out;
        }
        
        /* HI·ªÜU ·ª®NG BOSS KHI ƒêANG COOLDOWN (KH√îNG TH·ªÇ K√âO) */
        .boss-cooldown {
            box-shadow: 0 0 10px rgba(75, 85, 99, 0.6) !important; /* X√°m x·ªãt */
            cursor: not-allowed;
            opacity: 0.7;
        }

        .projectile {
            position: absolute;
            width: 15px;
            height: 15px;
            background-color: #ef4444; 
            border-radius: 50%;
            pointer-events: none;
            box-shadow: 0 0 10px #f87171;
            z-index: 9990;
        }
        
        /* ƒê·∫°n Ph·∫´n N·ªô */
        .enraged-projectile {
            position: absolute;
            width: 25px; /* L·ªõn h∆°n */
            height: 25px;
            background: linear-gradient(135deg, #f59e0b, #ef4444); /* M√†u cam/ƒë·ªè r·ª±c */
            border-radius: 50%;
            pointer-events: none;
            box-shadow: 0 0 15px #f59e0b;
            z-index: 9991;
            animation: pulse-glow 1s infinite alternate;
        }
        @keyframes pulse-glow {
            from { box-shadow: 0 0 10px #f59e0b; }
            to { box-shadow: 0 0 20px #ef4444; }
        }
        
        /* 5. Style cho Start Screen */
        #start-screen {
            background-color: rgba(31, 41, 55, 0.98); /* gray-800 opacity */
            z-index: 9999;
            transition: opacity 0.5s;
        }
    </style>
</head>
<!-- Body KH√îNG B·∫ÆT ƒê·∫¶U V·ªöI hide-cursor. M·∫∑c ƒë·ªãnh con tr·ªè h·ªá th·ªëng s·∫Ω hi·ªán ra. -->
<body class="bg-gray-900 text-white min-h-screen flex items-center justify-center p-4" id="document-body">

    <!-- custom-cursor b·∫Øt ƒë·∫ßu v·ªõi display: none -->
    <img id="custom-cursor" 
         src="https://tuanphong3108.github.io/mouse-game/cursor.png" 
         alt="Custom Cursor"
         onerror="this.src='https://placehold.co/40x40/fca5a5/1f2937?text=C'"
         draggable="false" 
         style="display: none;" 
    >

    <!-- Chu·ªôt FAKE d√πng ƒë·ªÉ l√†m animation V·ª† (Khi thua) -->
    <img id="fake-cursor-shatter" 
         src="https://tuanphong3108.github.io/mouse-game/cursor.png" 
         alt="Fake Cursor Shatter"
         onerror="this.src='https://placehold.co/40x40/fca5a5/1f2937?text=C'"
         draggable="false"
    >
    
    <!-- Khu v·ª±c Game ch√≠nh -->
    <div id="game-container" class="w-full max-w-4xl bg-gray-800 rounded-xl shadow-2xl p-6 md:p-10 border-4 border-red-500/50 relative overflow-hidden">
        <div id="game-content">
            <h1 class="text-3xl md:text-5xl font-extrabold text-red-400 mb-4 text-center">
                Cu·ªôc Chi·∫øn Con Tr·ªè
            </h1>
            <p class="text-gray-400 mb-4 text-center">
                (N√©m Boss ƒë·ªÉ g√¢y s√°t th∆∞∆°ng. N√© ƒë·∫°n ƒë·ªÉ kh√¥ng b·ªã Game Over!)
            </p>

            <!-- BOSS HP BAR -->
            <div id="hp-container" class="mb-4">
                <h2 class="text-xl font-bold text-red-300 mb-2 text-center">BOSS HP</h2>
                <div class="w-full bg-gray-600 rounded-full h-4 relative">
                    <div id="boss-hp-bar" class="bg-red-500 h-4 rounded-full transition-all duration-300" style="width: 100%"></div>
                </div>
            </div>

            <!-- Boss Arena -->
            <div id="boss-area" class="h-64 md:h-96 bg-gray-700 rounded-lg border-2 border-red-600/70 relative overflow-hidden">
                <!-- Boss Element -->
                <div id="boss" style="left: 50%; top: 50%;" draggable="false">
                    üëπ
                </div>
                <!-- V√πng ch·ª©a c√°c m·∫£nh v·ª° (Fragments) -->
                <div id="shatter-container" class="absolute inset-0 pointer-events-none"></div>
            </div>

            <!-- Game Status Area -->
            <div class="mt-4 flex flex-col md:flex-row justify-between items-center text-lg font-bold">
                <span id="score-display" class="text-green-400 mb-2 md:mb-0">Time Alive: 0.0s</span>
                <!-- Hi·ªÉn th·ªã HP c·ªßa Cursor -->
                <span id="cursor-hp-display" class="text-pink-400 flex items-center mb-2 md:mb-0">
                    ‚ù§Ô∏è 3
                </span>
                <span id="instruction-display" class="text-yellow-400 text-center">CLICK & DRAG BOSS!</span>
            </div>
        </div>

        <!-- Start Screen Message -->
        <div id="start-screen" class="absolute inset-0 flex flex-col items-center justify-center rounded-xl">
            <h2 class="text-6xl font-extrabold text-red-400 mb-6">
                S·∫¥N S√ÄNG CH∆ØA?
            </h2>
            <p class="text-xl text-gray-300 mb-10 text-center max-w-sm">
                Boss s·∫Ω t·∫•n c√¥ng ngay khi b·∫°n nh·∫•n B·∫ÆT ƒê·∫¶U. H√£y di chuy·ªÉn con tr·ªè!
            </p>
            <button id="play-button" onclick="startGame()" class="px-10 py-4 bg-green-500 hover:bg-green-600 rounded-2xl font-black transition-all duration-300 shadow-2xl text-xl transform hover:scale-105">
                B·∫ÆT ƒê·∫¶U (PLAY)
            </button>
        </div>


        <!-- Game Over / Game Win Message (Chung) -->
        <div id="game-over-message" class="absolute inset-0 bg-gray-900/95 flex flex-col items-center justify-center rounded-xl transition-opacity duration-500 opacity-0 pointer-events-none">
            <h2 class="text-5xl font-extrabold text-red-500 mb-4 animate-pulse">
                GAME OVER!
            </h2>
            <p class="text-2xl text-gray-300 mb-8">
                Con Tr·ªè Chu·ªôt ƒê√£ Hy Sinh Oanh Li·ªát! üò≠
            </p>
            <p class="text-xl text-gray-400 mb-8">
                B·∫°n s·ªëng s√≥t ƒë∆∞·ª£c: <span id="final-score" class="text-pink-400">0.0s</span>
            </p>
            <button onclick="resetGame()" class="px-8 py-3 bg-green-500 hover:bg-green-600 rounded-xl font-bold transition-all duration-300 shadow-xl text-lg">
                Ch∆°i L·∫°i
            </button>
        </div>
    </div>

    <!-- JavaScript Logic -->
    <script>
        // Global variables and constants
        const customCursor = document.getElementById('custom-cursor');
        const fakeCursorShatter = document.getElementById('fake-cursor-shatter');
        const gameOverMessage = document.getElementById('game-over-message');
        const documentBody = document.getElementById('document-body');
        const boss = document.getElementById('boss');
        const bossArea = document.getElementById('boss-area');
        const shatterContainer = document.getElementById('shatter-container');
        const scoreDisplay = document.getElementById('score-display');
        const finalScore = document.getElementById('final-score');
        const bossHpBar = document.getElementById('boss-hp-bar'); 
        const startScreen = document.getElementById('start-screen'); 
        const cursorHpDisplay = document.getElementById('cursor-hp-display'); 
        const instructionDisplay = document.getElementById('instruction-display');

        const BOSS_MAX_HP = 100;
        const CURSOR_MAX_HP = 3; 
        const INVULNERABILITY_TIME = 1500; // 1.5 gi√¢y b·∫•t t·ª≠ sau khi b·ªã tr√∫ng ƒë·∫°n

        let bossHP = BOSS_MAX_HP;
        let cursorHP = CURSOR_MAX_HP; 
        let isInvulnerable = false; 
        let gameState = 'ready'; 
        let projectiles = [];
        let bossTargetX = 0;
        let bossTargetY = 0;
        let score = 0;
        let lastTime = 0;

        let isDragging = false;
        let bossVX = 0; 
        let bossVY = 0; 
        let lastCursorX = 0;
        let lastCursorY = 0;
        let lastTimeDrag = 0;
        
        const BOSS_SIZE = 80;
        const PROJECTILE_SIZE = 15;
        
        // [C√ÇN B·∫∞NG GAME & ƒê·ªò KH√ì]
        const MIN_IMPACT_VELOCITY = 0.5; 
        // PHONG PATCH v2.0: Gi·∫£m h·ªá s·ªë s√°t th∆∞∆°ng n√©m xu·ªëng r·∫•t th·∫•p
        const DAMAGE_MULTIPLIER = 0.08; 
        
        // [ENRAGED MODE CONSTANTS]
        const ENRAGED_HP_THRESHOLD = BOSS_MAX_HP / 2; // 50 HP
        const ENRAGED_PROJECTILE_SPEED = 0.45; // px per ms (Nhanh g·∫•p ƒë√¥i)
        const ENRAGED_PROJECTILE_SIZE = 25; // L·ªõn h∆°n
        // PHONG PATCH v3.0: T·ªëc ƒë·ªô h·ªìi m√°u khi Boss ph·∫´n n·ªô (0.15 HP/s)
        const ENRAGED_HEAL_RATE = 0.15; 
        let isEnraged = false; // Tr·∫°ng th√°i Boss Ph·∫´n N·ªô

        // PHONG PATCH v3.0: THROW COOLDOWN LOGIC
        const THROW_COOLDOWN_MS = 500; // 0.5 gi√¢y cooldown gi·ªØa c√°c l·∫ßn k√©o Boss
        let canDragBoss = true; 

        // Kh·ªüi t·∫°o bi·∫øn cho ƒë·ªô kh√≥
        let PROJECTILE_FIRING_RATE = 1500; // ms (Th·ªùi gian ch·ªù gi·ªØa 2 l·∫ßn b·∫Øn)
        let PROJECTILE_SPEED = 0.2; // px per ms (T·ªëc ƒë·ªô ƒë·∫°n)
        let currentLevel = 1; // Level hi·ªán t·∫°i
        let projectileInterval; 
        
        // NgƒÉn ch·∫∑n menu chu·ªôt ph·∫£i (Context Menu) tr√™n to√†n b·ªô trang
        document.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });


        // --- GAME CONTROL FUNCTIONS ---

        // H√†m kh·ªüi ƒë·ªông Game: ·∫®n con tr·ªè h·ªá th·ªëng v√† hi·ªÉn th·ªã con tr·ªè custom
        function startGame() {
            if (gameState !== 'ready') return;
            gameState = 'playing';
            startScreen.style.opacity = '0';
            startScreen.style.pointerEvents = 'none';
            
            // 1. ·∫®n con tr·ªè h·ªá th·ªëng (v√¨ ƒë√£ c√≥ con tr·ªè custom)
            documentBody.classList.remove('show-cursor');
            documentBody.classList.add('hide-cursor'); 

            // 2. Hi·ªÉn th·ªã con tr·ªè custom
            customCursor.style.display = 'block';

            // B·∫Øt ƒë·∫ßu b·∫Øn ƒë·∫°n khi ·∫•n Play (d√πng bi·∫øn rate)
            projectileInterval = setInterval(fireProjectile, PROJECTILE_FIRING_RATE);
            
            // Kh·ªüi t·∫°o th·ªùi gian b·∫Øt ƒë·∫ßu
            lastTime = performance.now();
        }

        // 1. Theo d√µi chu·ªôt h·ªá th·ªëng v√† di chuy·ªÉn chu·ªôt custom
        documentBody.addEventListener('mousemove', (e) => {
            // Khi game over/win th√¨ kh√¥ng c·∫ßn di chuy·ªÉn custom cursor n·ªØa
            if (gameState === 'gameover' || gameState === 'gamewin') return;
            
            // Di chuy·ªÉn con tr·ªè custom (ch·ªâ hi·ªÉn th·ªã khi gameState l√† 'playing')
            if (gameState === 'playing') {
                customCursor.style.left = `${e.clientX}px`;
                customCursor.style.top = `${e.clientY}px`;
            }
            
            if (gameState === 'playing' && isDragging) {
                const bossRect = bossArea.getBoundingClientRect();
                const BossAreaWidth = bossRect.width - BOSS_SIZE;
                const BossAreaHeight = bossRect.height - BOSS_SIZE;
                
                const dx = e.clientX - lastCursorX;
                const dy = e.clientY - lastCursorY;
                const currentTime = performance.now();
                const dt = currentTime - lastTimeDrag;

                // Logic SNAPPING: T√≠nh to√°n v·ªã tr√≠ Boss (rel to bossArea)
                let targetX = e.clientX - bossRect.left - (BOSS_SIZE / 2); 
                let targetY = e.clientY - bossRect.top - (BOSS_SIZE / 2);
                
                // C·∫≠p nh·∫≠t v·∫≠n t·ªëc Boss (t√≠nh b·∫±ng pixel/ms)
                // H·ªá s·ªë ph√≥ng ƒë·∫°i l·ª±c n√©m
                const VELOCITY_SCALE = 2.5; 
                if (dt > 0) {
                    bossVX = (dx / dt) * VELOCITY_SCALE; 
                    bossVY = (dy / dt) * VELOCITY_SCALE;
                }
                
                // Gi·ªõi h·∫°n Boss trong Boss Area
                targetX = Math.max(0, Math.min(targetX, BossAreaWidth));
                targetY = Math.max(0, Math.min(targetY, BossAreaHeight));

                boss.style.left = `${targetX}px`;
                boss.style.top = `${targetY}px`;
                
                lastTimeDrag = currentTime;
            }
            
            lastCursorX = e.clientX;
            lastCursorY = e.clientY;
        });

        // 2. Boss Dragging Handlers
        boss.addEventListener('mousedown', (e) => {
            if (gameState !== 'playing' || bossHP <= 0) return;
            
            // PHONG PATCH v3.0: KI·ªÇM TRA COOLDOWN
            if (!canDragBoss) {
                // Hi·ªÉn th·ªã visual feedback n·∫øu kh√¥ng th·ªÉ k√©o
                instructionDisplay.textContent = 'GI√ÅP N√âM: ƒêang h·ªìi chi√™u...';
                boss.classList.add('boss-cooldown');
                setTimeout(() => {
                    boss.classList.remove('boss-cooldown');
                    if (!isEnraged) instructionDisplay.textContent = 'CLICK & DRAG BOSS!';
                }, 500); 
                return;
            }
            
            // Reset cooldown status and start dragging
            canDragBoss = false;
            isDragging = true;
            bossVX = 0;
            bossVY = 0;
            boss.style.transition = 'none'; 
            lastTimeDrag = performance.now();
            
            lastCursorX = e.clientX;
            lastCursorY = e.clientY;
        });

        documentBody.addEventListener('mouseup', () => {
            if (isDragging) {
                isDragging = false;
                boss.style.transition = 'left 2s ease-in-out, top 2s ease-in-out';
                
                // PHONG PATCH v3.0: K√çCH HO·∫†T COOLDOWN (0.5s)
                instructionDisplay.textContent = `GI√ÅP N√âM: ${THROW_COOLDOWN_MS/1000}s Cooldown`;
                boss.classList.add('boss-cooldown');
                
                setTimeout(() => {
                    canDragBoss = true;
                    boss.classList.remove('boss-cooldown');
                    if (!isEnraged) {
                        instructionDisplay.textContent = 'CLICK & DRAG BOSS!';
                    } else {
                        instructionDisplay.textContent = 'BOSS PH·∫™N N·ªò! C·∫®N TH·∫¨N ƒê·∫†N ƒê√îI & H·ªíI M√ÅU!';
                    }
                }, THROW_COOLDOWN_MS);
            }
        });


        // 3. C·∫≠p nh·∫≠t v·ªã tr√≠ Boss 
        function updateBoss(deltaTime) {
            if (gameState !== 'playing' || bossHP <= 0) return; 
            
            const bossRect = bossArea.getBoundingClientRect();
            const BossAreaWidth = bossRect.width - BOSS_SIZE;
            const BossAreaHeight = bossRect.height - BOSS_SIZE;

            let currentX = parseFloat(boss.style.left);
            let currentY = parseFloat(boss.style.top);
            
            if (isNaN(currentX)) currentX = BossAreaWidth / 2;
            if (isNaN(currentY)) currentY = BossAreaHeight / 2;

            if (!isDragging) {
                // √Åp d·ª•ng v·∫≠n t·ªëc n√©m v√† gi·∫£m t·ªëc (Friction/Drag)
                currentX += bossVX * deltaTime;
                currentY += bossVY * deltaTime;

                bossVX *= 0.99; 
                bossVY *= 0.99;
                
                // Di chuy·ªÉn Boss t·ª± ƒë·ªông 
                if (Math.abs(bossVX) < 0.05 && Math.abs(bossVY) < 0.05) {
                    const dx = bossTargetX - currentX;
                    const dy = bossTargetY - currentY;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance > 1) {
                        const step = Math.min(distance, 0.05 * deltaTime); 
                        currentX += (dx / distance) * step;
                        currentY += (dy / distance) * step;
                    }
                    
                    if (Math.random() < deltaTime / 3000) { 
                        bossTargetX = Math.random() * BossAreaWidth;
                        bossTargetY = Math.random() * BossAreaHeight;
                    }
                }
            }


            // 4. Boundary check and Damage on impact (N√©m v√†o t∆∞·ªùng)
            let damaged = false;
            
            // Check X boundary
            if (currentX < 0) {
                currentX = 0;
                if (Math.abs(bossVX) > MIN_IMPACT_VELOCITY) { 
                    damageBoss(Math.abs(bossVX) * DAMAGE_MULTIPLIER); 
                    bossVX *= -0.7; 
                    damaged = true;
                } else {
                    bossVX = 0;
                }
            } else if (currentX > BossAreaWidth) {
                currentX = BossAreaWidth;
                if (Math.abs(bossVX) > MIN_IMPACT_VELOCITY) {
                    damageBoss(Math.abs(bossVX) * DAMAGE_MULTIPLIER);
                    bossVX *= -0.7; 
                    damaged = true;
                } else {
                    bossVX = 0;
                }
            }

            // Check Y boundary
            if (currentY < 0) {
                currentY = 0;
                if (Math.abs(bossVY) > MIN_IMPACT_VELOCITY) {
                    damageBoss(Math.abs(bossVY) * DAMAGE_MULTIPLIER);
                    bossVY *= -0.7; 
                    damaged = true;
                } else {
                    bossVY = 0;
                }
            } else if (currentY > BossAreaHeight) {
                currentY = BossAreaHeight;
                if (Math.abs(bossVY) > MIN_IMPACT_VELOCITY) {
                    damageBoss(Math.abs(bossVY) * DAMAGE_MULTIPLIER);
                    bossVY *= -0.7; 
                    damaged = true;
                } else {
                    bossVY = 0;
                }
            }
            
            if(damaged) {
                boss.style.transition = 'none';
                boss.style.backgroundColor = '#f87171'; // Red-300
                document.getElementById('game-container').classList.add('shake-screen');
                
                setTimeout(() => { 
                    document.getElementById('game-container').classList.remove('shake-screen');
                    if (!isDragging) boss.style.transition = 'left 2s ease-in-out, top 2s ease-in-out'; 
                    boss.style.backgroundColor = 'rgba(239, 68, 68, 0.5)'; // M√†u g·ªëc 
                }, 100);
            }

            boss.style.left = `${currentX}px`;
            boss.style.top = `${currentY}px`;
        }


        // 5. Qu·∫£n l√Ω ƒê·∫°n (Projectile)
        function fireProjectile() {
            if (gameState !== 'playing' || bossHP <= 0 || isDragging) return; 

            const bRect = boss.getBoundingClientRect();
            const cRect = customCursor.getBoundingClientRect();
            
            const startX = bRect.left + bRect.width / 2;
            const startY = bRect.top + bRect.height / 2;
            
            const targetX = cRect.left + cRect.width / 2;
            const targetY = cRect.top + cRect.height / 2;

            const dx = targetX - startX;
            const dy = targetY - startY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // --- STANDARD PROJECTILE ---
            const speed = PROJECTILE_SPEED; 
            const vx = (dx / distance) * speed;
            const vy = (dy / distance) * speed;

            const projectileElement = document.createElement('div');
            projectileElement.className = 'projectile';
            projectileElement.style.position = 'fixed'; 
            projectileElement.style.left = `${startX - PROJECTILE_SIZE / 2}px`;
            projectileElement.style.top = `${startY - PROJECTILE_SIZE / 2}px`;
            documentBody.appendChild(projectileElement);

            projectiles.push({
                element: projectileElement,
                x: startX - PROJECTILE_SIZE / 2,
                y: startY - PROJECTILE_SIZE / 2,
                vx: vx,
                vy: vy,
                size: PROJECTILE_SIZE,
                isEnraged: false
            });
            
            // --- ENRAGED PROJECTILE (N·∫øu Boss Ph·∫´n N·ªô) ---
            if (isEnraged) {
                // T√°i s·ª≠ d·ª•ng t√≠nh to√°n v·∫≠n t·ªëc nh∆∞ng v·ªõi t·ªëc ƒë·ªô/k√≠ch th∆∞·ªõc kh√°c
                const enragedSpeed = ENRAGED_PROJECTILE_SPEED;
                const enragedVx = (dx / distance) * enragedSpeed;
                const enragedVy = (dy / distance) * enragedSpeed;

                const enragedElement = document.createElement('div');
                enragedElement.className = 'enraged-projectile'; // D√πng class m·ªõi
                enragedElement.style.position = 'fixed'; 
                enragedElement.style.left = `${startX - ENRAGED_PROJECTILE_SIZE / 2}px`;
                enragedElement.style.top = `${startY - ENRAGED_PROJECTILE_SIZE / 2}px`;
                documentBody.appendChild(enragedElement);

                projectiles.push({
                    element: enragedElement,
                    x: startX - ENRAGED_PROJECTILE_SIZE / 2,
                    y: startY - ENRAGED_PROJECTILE_SIZE / 2,
                    vx: enragedVx,
                    vy: enragedVy,
                    size: ENRAGED_PROJECTILE_SIZE,
                    isEnraged: true
                });
            }
        }

        // 6. C·∫≠p nh·∫≠t v·ªã tr√≠ ƒë·∫°n v√† ki·ªÉm tra va ch·∫°m
        function updateProjectiles(deltaTime) {
            const cRect = customCursor.getBoundingClientRect();
            const newProjectiles = [];

            for (let i = 0; i < projectiles.length; i++) {
                const p = projectiles[i];
                p.x += p.vx * deltaTime;
                p.y += p.vy * deltaTime;

                p.element.style.left = `${p.x}px`;
                p.element.style.top = `${p.y}px`;

                // Ki·ªÉm tra va ch·∫°m v·ªõi Chu·ªôt (margin ƒë∆∞·ª£c ƒëi·ªÅu ch·ªânh theo k√≠ch th∆∞·ªõc)
                const collisionMargin = p.isEnraged ? 5 : 10; 
                
                if (!isInvulnerable && checkCollision(cRect, p.element.getBoundingClientRect(), collisionMargin)) {
                    damageCursor(); // G√¢y s√°t th∆∞∆°ng cho chu·ªôt
                    p.element.remove(); // X√≥a ƒë·∫°n ƒë√£ ch·∫°m
                    
                    // N·∫øu Chu·ªôt ƒë√£ Game Over, d·ª´ng x·ª≠ l√Ω
                    if (gameState !== 'playing') return; 

                    continue; // B·ªè qua ph·∫ßn th√™m v√†o newProjectiles v√¨ ƒë·∫°n ƒë√£ b·ªã x√≥a
                }

                // Gi·ªØ l·∫°i ƒë·∫°n c√≤n trong m√†n h√¨nh
                if (p.x > -p.size && p.x < window.innerWidth && p.y > -p.size && p.y < window.innerHeight) {
                    newProjectiles.push(p);
                } else {
                    p.element.remove();
                }
            }
            projectiles = newProjectiles;
        }

        // 7. Ki·ªÉm tra va ch·∫°m
        function checkCollision(rect1, rect2, margin = 0) {
            return (
                rect1.left < rect2.right - margin &&
                rect1.right > rect2.left + margin &&
                rect1.top < rect2.bottom - margin &&
                rect1.bottom > rect2.top + margin
            );
        }

        // 8. C·∫≠p nh·∫≠t HP Boss
        function damageBoss(amount) {
            if (bossHP <= 0 || gameState !== 'playing') return;
            
            bossHP -= amount;
            
            if (bossHP < 0) bossHP = 0;
            
            updateHPBar();

            if (bossHP === 0) {
                triggerGameWin();
            }
        }
        
        function updateHPBar() {
             const percent = (bossHP / BOSS_MAX_HP) * 100;
             bossHpBar.style.width = `${percent}%`;
             
             // C·∫≠p nh·∫≠t m√†u s·∫Øc HP Bar v√† ki·ªÉm tra Enraged Mode
             if (percent < 20) {
                 bossHpBar.classList.remove('bg-red-500', 'bg-red-700/80');
                 bossHpBar.classList.add('bg-orange-500');
             } else if (percent < 50) { 
                 bossHpBar.classList.remove('bg-orange-500', 'bg-red-500');
                 bossHpBar.classList.add('bg-red-700/80');
                 
                 // K√çCH HO·∫†T ENRAGED MODE
                 if (!isEnraged) {
                     isEnraged = true;
                     boss.textContent = 'üòà'; // Bi·ªÉu c·∫£m Boss khi Enraged
                     instructionDisplay.textContent = 'BOSS PH·∫™N N·ªò! C·∫®N TH·∫¨N ƒê·∫†N ƒê√îI & H·ªíI M√ÅU!';
                     console.log('BOSS ENRAGED! Passive Healing Active.');
                 }
             } else {
                 bossHpBar.classList.remove('bg-orange-500', 'bg-red-700/80');
                 bossHpBar.classList.add('bg-red-500');
                 
                 // T·∫ÆT ENRAGED MODE (N·∫øu Boss h·ªìi m√°u v∆∞·ª£t 50% - n·∫øu c√≥ c∆° ch·∫ø h·ªìi m√°u m·∫°nh)
                 if (isEnraged) {
                    isEnraged = false;
                    boss.textContent = 'üëπ'; 
                    instructionDisplay.textContent = 'CLICK & DRAG BOSS!';
                    console.log('BOSS CALMED DOWN (Should not happen unless healed past 50%)');
                 }
             }
        }
        
        // G√¢y s√°t th∆∞∆°ng cho Chu·ªôt v√† k√≠ch ho·∫°t B·∫•t t·ª≠
        function damageCursor() {
            if (isInvulnerable || gameState !== 'playing') return;

            cursorHP--;
            updateCursorHPDisplay();
            
            // K√≠ch ho·∫°t Invulnerability (I-frames)
            isInvulnerable = true;
            customCursor.classList.add('cursor-hit');

            setTimeout(() => {
                isInvulnerable = false;
                customCursor.classList.remove('cursor-hit');
            }, INVULNERABILITY_TIME);
            
            // Check Game Over
            if (cursorHP <= 0) {
                triggerGameOver();
            }
        }

        // C·∫≠p nh·∫≠t hi·ªÉn th·ªã HP c·ªßa Chu·ªôt
        function updateCursorHPDisplay() {
             const hearts = '‚ù§Ô∏è';
             cursorHpDisplay.innerHTML = `${hearts.repeat(cursorHP)} <span class="text-xl">${cursorHP}</span>`;

             if (cursorHP === 1) {
                 cursorHpDisplay.classList.remove('text-pink-400');
                 cursorHpDisplay.classList.add('text-red-500', 'animate-pulse');
             } else {
                 cursorHpDisplay.classList.remove('text-red-500', 'animate-pulse');
                 cursorHpDisplay.classList.add('text-pink-400');
             }
        }

        
        // C·∫≠p nh·∫≠t ƒë·ªô kh√≥ (tƒÉng t·ªëc ƒë·ªô ƒë·∫°n v√† t·∫ßn su·∫•t b·∫Øn nhanh h∆°n)
        function updateDifficulty() {
            // Level tƒÉng m·ªói 10 gi√¢y
            const nextLevelThreshold = currentLevel * 10; 
            
            if (score >= nextLevelThreshold) {
                currentLevel++;
                
                // TƒÉng t·ªëc ƒë·ªô ƒë·∫°n: Level 1 (0.2), Level 2 (0.25), Level 3 (0.3), ...
                PROJECTILE_SPEED = 0.2 + (currentLevel - 1) * 0.05;
                
                // Gi·∫£m t·∫ßn su·∫•t b·∫Øn: Level 1 (1500ms), Level 2 (1200ms), Level 3 (900ms), T·ªëi thi·ªÉu 500ms
                PROJECTILE_FIRING_RATE = Math.max(500, 1500 - (currentLevel - 1) * 300); 

                // Reset interval v·ªõi rate m·ªõi
                clearInterval(projectileInterval);
                projectileInterval = setInterval(fireProjectile, PROJECTILE_FIRING_RATE);
                
                // C·∫≠p nh·∫≠t h∆∞·ªõng d·∫´n t·∫°m th·ªùi
                if (!isEnraged) {
                     instructionDisplay.textContent = `LEVEL UP! C·∫•p ƒë·ªô: ${currentLevel}`;
                }

                setTimeout(() => {
                    // Ch·ªâ hi·ªÉn th·ªã l·∫°i h∆∞·ªõng d·∫´n c≈© n·∫øu Boss ch∆∞a Enraged v√† kh√¥ng ƒëang cooldown
                    if(canDragBoss) {
                        if(!isEnraged) { 
                            instructionDisplay.textContent = 'CLICK & DRAG BOSS!';
                        } else {
                            instructionDisplay.textContent = 'BOSS PH·∫™N N·ªò! C·∫®N TH·∫¨N ƒê·∫†N ƒê√îI & H·ªíI M√ÅU!';
                        }
                    }
                }, 2000);

                console.log(`ƒê·ªô kh√≥ tƒÉng l√™n Level ${currentLevel}. Speed: ${PROJECTILE_SPEED.toFixed(2)}, Rate: ${PROJECTILE_FIRING_RATE}ms`);
            }
        }


        // 9. Logic Game Loop
        function gameLoop(timestamp) {
            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;

            if (gameState === 'playing') {
                score += deltaTime / 1000;
                scoreDisplay.textContent = `Time Alive: ${score.toFixed(2)}s`;
                
                updateDifficulty(); 
                updateBoss(deltaTime);
                updateProjectiles(deltaTime);
                
                // PHONG PATCH v2.0 & v3.0: LOGIC H·ªíI M√ÅU PH·∫™N N·ªò
                if (isEnraged && bossHP > 0) {
                    // H·ªìi m√°u d·ª±a tr√™n th·ªùi gian (HP = 0.15/gi√¢y)
                    const healAmount = ENRAGED_HEAL_RATE * (deltaTime / 1000);
                    bossHP += healAmount; 
                    bossHP = Math.min(bossHP, BOSS_MAX_HP); // Kh√¥ng v∆∞·ª£t qu√° HP t·ªëi ƒëa
                    updateHPBar();
                }
            }
            
            requestAnimationFrame(gameLoop);
        }

        // 10. K√≠ch ho·∫°t Game Over (Thua v√¨ ch·∫°m ƒë·∫°n)
        function triggerGameOver() {
            if (gameState !== 'playing') return;
            gameState = 'gameover';
            
            // B·∫¨T L·∫†I con tr·ªè h·ªá th·ªëng ƒë·ªÉ user click ƒë∆∞·ª£c n√∫t Play Again
            documentBody.classList.remove('hide-cursor'); // T·∫Øt ·∫©n
            documentBody.classList.add('show-cursor'); // B·∫≠t hi·ªán (cho r√µ r√†ng)
            
            // ·∫®n con tr·ªè custom
            const cursorRect = customCursor.getBoundingClientRect();
            const centerX = cursorRect.left + cursorRect.width / 2;
            const centerY = cursorRect.top + cursorRect.height / 2;
            customCursor.style.display = 'none';
            
            // K√≠ch ho·∫°t hi·ªáu ·ª©ng v·ª°
            fakeCursorShatter.style.display = 'block';
            fakeCursorShatter.style.left = `${centerX}px`;
            fakeCursorShatter.style.top = `${centerY}px`;
            fakeCursorShatter.classList.remove('shatter-effect'); 
            void fakeCursorShatter.offsetWidth; 
            fakeCursorShatter.classList.add('shatter-effect');
            
            for (let i = 0; i < 10; i++) {
                createFragment(centerX, centerY);
            }

            setTimeout(() => {
                gameOverMessage.querySelector('h2').textContent = 'GAME OVER!';
                gameOverMessage.querySelector('p').textContent = 'Con Tr·ªè Chu·ªôt ƒê√£ Hy Sinh Oanh Li·ªát! üò≠';
                gameOverMessage.style.opacity = '1';
                gameOverMessage.style.pointerEvents = 'auto';
                finalScore.textContent = `${score.toFixed(2)}s`;
            }, 500);

            clearInterval(projectileInterval); 
        }

        // 11. K√≠ch ho·∫°t Game Win (Th·∫Øng v√¨ h·∫° Boss)
        function triggerGameWin() {
            if (gameState !== 'playing') return;
            gameState = 'gamewin';
            
            // B·∫¨T L·∫†I con tr·ªè h·ªá th·ªëng ƒë·ªÉ user click ƒë∆∞·ª£c n√∫t Play Again
            documentBody.classList.remove('hide-cursor');
            documentBody.classList.add('show-cursor');

            // D·ª´ng b·∫Øn ƒë·∫°n, x√≥a Boss
            clearInterval(projectileInterval); 
            boss.style.display = 'none';
            projectiles.forEach(p => p.element.remove());
            projectiles = [];
            
            // ·∫®n con tr·ªè custom
            customCursor.style.display = 'none';
            
            // Hi·ªÉn th·ªã th√¥ng b√°o chi·∫øn th·∫Øng
            setTimeout(() => {
                gameOverMessage.querySelector('h2').textContent = 'CHI·∫æN TH·∫ÆNG!';
                gameOverMessage.querySelector('h2').classList.remove('text-red-500');
                gameOverMessage.querySelector('h2').classList.add('text-green-500');
                gameOverMessage.querySelector('p').textContent = 'B·∫°n ƒë√£ h·∫° g·ª•c Boss th√†nh c√¥ng! üéâ';
                gameOverMessage.querySelector('button').classList.remove('bg-green-500');
                gameOverMessage.querySelector('button').classList.add('bg-blue-500');
                gameOverMessage.style.opacity = '1';
                gameOverMessage.style.pointerEvents = 'auto';
                finalScore.textContent = `${score.toFixed(2)}s`;
            }, 500);
        }


        // 12. T·∫°o m·∫£nh v·ª° (Fragment)
        function createFragment(absoluteX, absoluteY) {
            const fragment = document.createElement('div');
            fragment.className = 'fragment';
            
            const shatterRect = shatterContainer.getBoundingClientRect();
            const relativeX = absoluteX - shatterRect.left;
            const relativeY = absoluteY - shatterRect.top;

            fragment.style.left = `${relativeX}px`;
            fragment.style.top = `${relativeY}px`;

            const angle = Math.random() * 2 * Math.PI;
            const speed = 50 + Math.random() * 100; 
            let vx = Math.cos(angle) * speed;
            let vy = Math.sin(angle) * speed;

            shatterContainer.appendChild(fragment);

            function animateFragment(fragTime) {
                if (parseFloat(fragment.style.opacity) <= 0 || gameState !== 'gameover') {
                    fragment.remove();
                    return;
                }

                const newX = parseFloat(fragment.style.left) + vx * (fragTime / 1000);
                const newY = parseFloat(fragment.style.top) + vy * (fragTime / 1000) + 0.98 * (fragTime / 1000)**2; 

                fragment.style.left = `${newX}px`;
                fragment.style.top = `${newY}px`;
                
                vx *= 0.99;
                vy *= 0.99;
                
                if (fragTime > 1000) {
                    fragment.style.opacity = 0;
                    setTimeout(() => fragment.remove(), 500);
                    return;
                }

                requestAnimationFrame(animateFragment.bind(null, fragTime + 16)); 
            }
            animateFragment(0);
        }

        // 13. Reset game (Reload page)
        function resetGame() {
            window.location.reload(); 
        }

        // --- GAME INITIALIZATION ---
        requestAnimationFrame(gameLoop);
        
        boss.style.left = '50%';
        boss.style.top = '50%';
        bossTargetX = 0;
        bossTargetY = 0;
        
        updateHPBar();
        updateCursorHPDisplay(); 
        
        console.log("Game ƒë√£ ·ªü tr·∫°ng th√°i READY. Con tr·ªè h·ªá th·ªëng ƒëang hi·ªÉn th·ªã ƒë·ªÉ click n√∫t Play.");

    </script>

</body>
</html>
